<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Computer Organization and Architecture - 分类 - Jungle&#39;s Blog</title>
        <link>https://Jungle430.github.io/categories/computer-organization-and-architecture/</link>
        <description>Computer Organization and Architecture - 分类 - Jungle&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1239946358@qq.com (Jungle)</managingEditor>
            <webMaster>1239946358@qq.com (Jungle)</webMaster><lastBuildDate>Thu, 12 Jan 2023 21:02:20 &#43;0800</lastBuildDate><atom:link href="https://Jungle430.github.io/categories/computer-organization-and-architecture/" rel="self" type="application/rss+xml" /><item>
    <title>Computer Organization and Architecture Computer Evolution and Performance</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-computer-evolution-and-performance/</link>
    <pubDate>Thu, 12 Jan 2023 21:02:20 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-computer-evolution-and-performance/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="computer-evolution-and-performance">Computer Evolution and Performance</h2>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>A Brief History of Computers</p>
</li>
<li>
<p>Designing for Performance</p>
</li>
<li>
<p>Performance Assessment</p>
</li>
<li>
<p><code>Intel x86</code> and <code>ARM</code> processor families</p>
</li>
<li>
<p>Computer Types</p>
</li>
</ul>
<h3 id="a-brief-history-of-computers">A Brief History of Computers</h3>
<h4 id="eniac--the-first-computer"><code>ENIAC</code> – the first computer</h4>
<ul>
<li>
<p><code>ENIAC</code>，<strong>Electronic Numerical Integrator And Computer</strong></p>
</li>
<li>
<p>For war purposes, to compute the ballistic trajectory</p>
</li>
<li>
<p>Started in 1943, finished in 1946 (too late for war purpose)</p>
</li>
<li>
<p>In university of Pennsylvania，By Professor <code>John Mauchly</code> and his student <code>John P Eckert</code>，Use Vacuum Tubes</p>
</li>
<li>
<p>Weighted 30 tons, consumes $140kw$ of electric power, 1500 square feet of space, only 5000 addition per second</p>
</li>
<li>
<p><strong>As milestone of science development</strong>, used until 1995</p>
</li>
</ul>
<h5 id="detail-of-eniac">Detail of <code>ENIAC</code></h5>
<ul>
<li>
<p><strong>Decimal，not binary</strong></p>
</li>
<li>
<p>10 vacuum tubes represent each digit, <strong>at any time only one vacuum tube was in the ON state</strong></p>
</li>
<li>
<p>20 accumulators of 10-digit decimal number</p>
</li>
<li>
<p>5000 additions per second</p>
</li>
<li>
<p><strong>Programmed manually by switches</strong></p>
</li>
<li>
<p><strong>No microprocessors</strong></p>
</li>
<li>
<p><strong>No memory</strong></p>
</li>
<li>
<p><strong>Changing the program could take days!</strong></p>
</li>
</ul>
<h5 id="main-shortcoming-of-eniac">Main shortcoming of <code>ENIAC</code></h5>
<ul>
<li>
<p>No memory</p>
</li>
<li>
<p>The task of entering and altering programs was extremely tedious</p>
</li>
</ul>
<h4 id="how-to-overcome-this-problem">How to overcome this problem?</h4>
<ul>
<li>
<p>The <strong>stored-program concept</strong> had been proposed</p>
<ul>
<li>
<p><code>John von Neumann</code> $\rightarrow$ <code>“father of compute” and &quot;father of game theory&quot;,Completed &quot;computer and brain&quot; and &quot;self breeding automata theory&quot;, is the embryonic form of &quot;artificial intelligence&quot; field</code></p>
</li>
<li>
<p><code>Alan Turing</code> $\rightarrow$ <code>“father of artificial intelligence” &amp; &quot;annual Turing prize&quot;</code></p>
</li>
<li>
<p>First publication of the idea was in 1945 proposal by <code>von Neumann</code> for <code>EDVAC</code>（Electronic Discrete Variable Automatic Computer)</p>
</li>
</ul>
</li>
<li>
<p>Our current computer is still called the <code>von Neumann machine</code></p>
</li>
</ul>
<h4 id="characteristics-of-stored-program-concept">Characteristics of Stored Program concept</h4>
<ul>
<li>
<p><strong>A main memory, which stores both data and instructions</strong></p>
</li>
<li>
<p><strong>Binary numbers for both data and instructions</strong></p>
</li>
<li>
<p><strong>An arithmetic-logic unit performs the basic operations</strong></p>
</li>
<li>
<p><strong>The data and instructions are stored in the memory, selected by addresses</strong></p>
</li>
<li>
<p><strong>The proper sequencing of the operation is controlled by a control unit</strong></p>
</li>
</ul>
<h4 id="the-von-neumann-machine">The <code>von Neumann Machine</code></h4>
<ul>
<li>
<p><code>IAS</code>（Institute of Advanced Studies）,started in 1946</p>
</li>
<li>
<p><strong>5 functional units</strong></p>
<ul>
<li><strong>ALU, memory, control unit, input devices, output devices</strong></li>
</ul>
</li>
<li>
<p>NOT Completed until 1952</p>
</li>
<li>
<p><strong>Until now, most computers are still structured based on this concept</strong></p>
</li>
<li>
<p>$CPU(Central\ Processing\ Unit)=ALU(Arithmetic-Logic\ Unit)+CU(Program\ Control\ Unit)\newline$</p>
</li>
<li>
<p>There are connections between main memory and ALU and CU. Through the connection with CU, it receives the control signal from CU and transmits the data to ALU</p>
</li>
<li>
<p>IO device for data input and output</p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-1.png" title="/img/Computer Organization and Architecture/chapter2-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-1.png" data-sub-html="<h2>Organization(Von Neumann Machine)</h2>">
        
    </a><figcaption class="image-caption">Organization(<code>Von Neumann Machine</code>)</figcaption>
    </figure>
<h5 id="details-of-ias">Details of <code>IAS</code></h5>
<ul>
<li>
<p><code>IAS</code>: Institute for Advanced Studies, Princeton</p>
</li>
<li>
<p><strong>Memory</strong>: $1000 \times 40\ bit\ words$ in binary number</p>
<ul>
<li><strong>Both data and instructions are stored there</strong></li>
</ul>
</li>
<li>
<p>Each number is represented by <strong>a sign bit and a 39-bit value</strong></p>
</li>
</ul>
<hr>
<ul>
<li>
<p>A word may also contain two 20-bit instructions</p>
<ul>
<li>
<p>an 8-bit operation code</p>
</li>
<li>
<p>a 12-bit address</p>
</li>
</ul>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-2.png" title="/img/Computer Organization and Architecture/chapter2-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-2.png" data-sub-html="<h2>instructions</h2>">
        
    </a><figcaption class="image-caption"><code>instructions</code></figcaption>
    </figure>
<h5 id="registers-of-ias">Registers of <code>IAS</code></h5>
<p><strong>Several registers are set inside the CPU to temporarily save data</strong></p>
<ul>
<li>Memory Buffer Register</li>
<li>Memory Address Register</li>
<li>Instruction Register</li>
<li>Instruction Buffer Register</li>
<li>Program Counter</li>
<li>Accumulator</li>
<li>Multiplier Quotient</li>
</ul>
<h5 id="ias-control-unit"><code>IAS</code> control unit</h5>
<ul>
<li>The control unit operates the <code>IAS</code> by fetching instructions from memory and executing them one at a time</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-3.png" title="/img/Computer Organization and Architecture/chapter2-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-3.png" data-sub-html="<h2>IAS(Control unit)</h2>">
        
    </a><figcaption class="image-caption">IAS(<code>Control unit</code>)</figcaption>
    </figure>
<h5 id="fetch-cycle">Fetch cycle</h5>
<ul>
<li>
<p><strong>If <code>IBR</code> is not empty, directly execute the instruction</strong></p>
</li>
<li>
<p><strong>If <code>IBR</code> is empty, first fetch instruction, then execute instruction</strong></p>
</li>
</ul>
<h5 id="execute-cycle">Execute cycle</h5>
<ul>
<li>
<p>Instruction enters the control circuit to control the execution of the command</p>
</li>
<li>
<p><strong>Address in <code>MAR</code> represents the address of the operand</strong></p>
</li>
</ul>
<h5 id="instruction-types"><strong>Instruction types</strong></h5>
<ul>
<li>
<p>Data transfer</p>
<ul>
<li>
<p>Memory – ALU registers</p>
</li>
<li>
<p>Register – Register</p>
</li>
</ul>
</li>
<li>
<p>Unconditional branch</p>
</li>
<li>
<p>Conditional branch</p>
</li>
<li>
<p>Arithmetic</p>
</li>
<li>
<p>Address modify</p>
</li>
</ul>
<h4 id="development-of-computer">Development of computer</h4>
<ul>
<li>
<p>Von Neumann machine : initial stage of computer</p>
</li>
<li>
<p>Computer architecture they proposed laid a solid foundation for the development of computers in the future</p>
</li>
<li>
<p>Original computers most for special purposes</p>
</li>
<li>
<p>With the development of technology, computers have gradually turned from special purpose to commercial use</p>
</li>
</ul>
<h4 id="commercial-computers">Commercial Computers</h4>
<ul>
<li>
<p><code>Eckert-Mauchly</code> Computer Corporation利计算机公司</p>
<ul>
<li>
<p><code>Mauchly </code>and his student <code>Eckert</code> built the first computer <code>ENIAC</code></p>
</li>
<li>
<p>In 1947,<code>Eckert</code> and <code>Mauchly</code> formed the corporation</p>
</li>
<li>
<p>UNIVAC I: first commercial computer</p>
</li>
<li>
<p>UNIVAC II: <strong>backward compatible</strong></p>
</li>
<li>
<p>As a department of Sperry-Rand Corporation</p>
</li>
</ul>
</li>
</ul>
<h4 id="ibm">IBM</h4>
<ul>
<li>
<p>The major manufacturer of punched-card processing equipment then</p>
</li>
<li>
<p>1953 - the 701</p>
<ul>
<li>
<p>IBM’s first stored program computer</p>
</li>
<li>
<p>Scientific calculations</p>
</li>
</ul>
</li>
<li>
<p>1955 - the 702</p>
<ul>
<li>Business applications</li>
</ul>
</li>
<li>
<p>Lead to 700/7000 series</p>
</li>
<li>
<p><strong>Made IBM the dominant computer manufacturer</strong></p>
</li>
</ul>
<h4 id="summary-of-first-generation">Summary of first generation</h4>
<ul>
<li>
<p><strong>Use electronic tubes as the main components</strong></p>
<ul>
<li>
<p>Electronic tube is composed of wire, metal sheet, glass shell and vacuum tube</p>
</li>
<li>
<p>Large in volume, hot and expensive</p>
</li>
<li>
<p>Restrict the development of computer. use.</p>
</li>
</ul>
</li>
</ul>
<h4 id="second-generation--transistors">Second generation : transistors</h4>
<ul>
<li>
<p>Replaced <strong>vacuum tubes</strong></p>
<ul>
<li>
<p>Invented 1947 at Bell Labs</p>
</li>
<li>
<p>Smaller</p>
</li>
<li>
<p>Cheaper</p>
</li>
<li>
<p>Less heat dissipation</p>
</li>
<li>
<p>Made from <strong>Silicon</strong></p>
</li>
</ul>
</li>
<li>
<p>This results</p>
<ul>
<li>
<p>More complex arithmetic, logic units, control units</p>
</li>
<li>
<p>More powerful, more complex control</p>
</li>
<li>
<p>High-level language, system software</p>
</li>
</ul>
</li>
<li>
<p><strong>Transistors are the hallmark of the second generation of computers</strong></p>
</li>
</ul>
<p><strong>Transistor based computer</strong>(history)</p>
<ul>
<li>
<p>Second generation machines</p>
</li>
<li>
<p>NCR &amp; RCA produced small transistor machines (front-runner of this field, RCA is more successful)</p>
</li>
<li>
<p>IBM 7000 series</p>
<ul>
<li>
<p>1960: 7090</p>
</li>
<li>
<p><strong>1964: 7094，the lase member of the 7000 series</strong></p>
<ul>
<li>
<p><strong>Data Channel</strong></p>
</li>
<li>
<p><strong>Multiplexer</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DEC（Digital Equipment Corporation,Alpha chip）- 1957</p>
</li>
<li>
<p>Produced PDP-1</p>
</li>
</ul>
<p><strong>Example of transistor board</strong>(history)</p>
<ul>
<li>
<p><strong>Philco 212 Transistor Boards, 1962</strong></p>
<ul>
<li>
<p>Electronic components are manually welded to the circuit board to form a complex circuit board</p>
</li>
<li>
<p>Heavy workload</p>
</li>
<li>
<p>Easy to fail</p>
</li>
</ul>
</li>
</ul>
<h5 id="ibm-7094"><strong>IBM 7094</strong></h5>
<ul>
<li>
<p>IBM 7094 is a representative of the second generation</p>
<ul>
<li>
<p><strong>It is a central-switched architecture</strong></p>
</li>
<li>
<p><strong>It uses data channels and multiplexor</strong></p>
<ul>
<li>
<p><strong>A data channel is an independent I/O module with its own processor and its own instruction set</strong></p>
</li>
<li>
<p><strong>Multiplexor is the central termination point for data channels, the CPU, and memory</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Configuration of 7094</strong></p>
<ul>
<li>
<p><strong>Total 4 data channels</strong> are connected to multiple devices, including disks, tapes, printers, etc</p>
</li>
<li>
<p><strong>Four channels, CPU and memory are connected to the multiplexer for scheduling and independent accessfail</strong></p>
</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-4.png" title="/img/Computer Organization and Architecture/chapter2-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-4.png" data-sub-html="<h2>Configuration of 7094</h2>">
        
    </a><figcaption class="image-caption"><code>Configuration of 7094</code></figcaption>
    </figure>
<h4 id="shortcoming-of-transistor-and-development">Shortcoming of transistor and development</h4>
<ul>
<li>
<p>Shortcoming of transistor</p>
<ul>
<li>
<p>Discrete components were manufactured separately</p>
</li>
<li>
<p>The entire manufacturing process, from transistor to circuit board, was expensive and cumbersome</p>
</li>
<li>
<p>More than 10000 transistor in computer</p>
</li>
</ul>
</li>
<li>
<p>Development: <strong>Microelectronics</strong></p>
<ul>
<li>
<p>The invention of the integrated circuit in 1958</p>
</li>
<li>
<p>The third generation of computers</p>
</li>
</ul>
</li>
</ul>
<h4 id="microelectronics">Microelectronics</h4>
<ul>
<li>
<p>Two elements <strong>(gates and memory cells)</strong> are necessary for the main functions of computer&ndash;storage, movement, processing, and control</p>
</li>
<li>
<p>From the view of microelectronics , a computer consists of</p>
<ul>
<li>
<p><strong>Gates: processing</strong></p>
</li>
<li>
<p><strong>memory cells : storage</strong></p>
</li>
<li>
<p><strong>interconnections among these elements: movement and control</strong></p>
</li>
</ul>
</li>
<li>
<p>Transistors, resistors, and conductors can be made by semiconductor</p>
</li>
<li>
<p>The whole circuit is mounted on a very small silicon chip instead of an equivalent circuit made of discrete components</p>
</li>
<li>
<p>A silicon wafer is divided into several chips, each chip contains exactly the same circuit</p>
</li>
<li>
<p>After cutting, packaging and adding pins, it becomes a chip</p>
</li>
</ul>
<h4 id="moores-law">Moore’s Law</h4>
<p><strong>Pronounced in 1965 by Gordon Moore- cofounder of Intel</strong></p>
<blockquote>
<p>The number of transistors on a semiconductor chip doubles approximately every 18 month(or increases ten-fold approximately every 5 years) $\rightarrow Moore&rsquo;s\ Law\newline$</p>
</blockquote>
<p>$N=a \times 10^{\frac{1}{5} \times t}\newline$</p>
<blockquote>
<p>Microprocessors get smaller,more compact and faster and faster!</p>
</blockquote>
<hr>
<p>Some facts revealed by <code>Moore‘s Law</code></p>
<ul>
<li>
<p>Cost of a chip has remained almost unchanged: the cost of computer has fallen</p>
</li>
<li>
<p>Higher packing density means shorter electrical paths, giving higher speed</p>
</li>
<li>
<p>Smaller size making it more convenient to place in a variety of environments</p>
</li>
<li>
<p>Reduced power and cooling requirements</p>
</li>
<li>
<p>Fewer interconnections increases reliability</p>
</li>
</ul>
<h4 id="the-computer-family-concept">The computer family concept</h4>
<ul>
<li>
<p>The <strong>characteristics</strong> of a computer family are</p>
<ul>
<li>
<p><strong>Similar or identical instruction set</strong></p>
</li>
<li>
<p><strong>Similar or identical operating system</strong></p>
</li>
<li>
<p>Increasing speed</p>
</li>
<li>
<p>Increasing number of I/O ports</p>
</li>
<li>
<p>Increasing memory size</p>
</li>
<li>
<p>Increasing cost</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>IBM System/360</strong></p>
<ul>
<li>
<p>By 1964, IBM announced System/360 family, this was the industry‘s first planned family of computers.</p>
<ul>
<li>
<p>The family covered a wide range of performance and cost</p>
</li>
<li>
<p>A program written can be executed by all models of the family, with only a difference in the speed</p>
</li>
<li>
<p>The customer can start with lower model and upgrade to the higher when it is needed</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>DEC PDP-8</strong></p>
<ul>
<li>
<p>In the same year(1964), Digital Equipment Corporation (DEC) announced PDP-8</p>
<ul>
<li>Small，desktop</li>
<li>Lower cost，$16k</li>
</ul>
</li>
<li>
<p>These features enabled another manufacturer to purchase a PDP-8 and integrate it into a different system for resale</p>
<ul>
<li>These manufacturers came to be known as original equipment manufacturers<code> (OEMs)</code></li>
</ul>
</li>
</ul>
<hr>
<p><strong>Detail of DEC PDP-8</strong></p>
<ul>
<li>
<p><strong>Later models used the bus structure</strong> consists of 96 signal lines to carry control, address, and data signals</p>
</li>
<li>
<p><strong>The architecture is highly flexible, allowing modules to be plugged into the bus to create various configurations</strong></p>
</li>
<li>
<p><strong>Bus architecture is now widely used</strong></p>
</li>
</ul>
<h4 id="generations-of-computer">Generations of computer</h4>
<ul>
<li>
<p>Vacuum tube :1946-1957</p>
</li>
<li>
<p>Transistor : 1958-1964</p>
</li>
<li>
<p>Small scale integration : 1965 on</p>
<ul>
<li>Up to 100 devices on a chip</li>
</ul>
</li>
<li>
<p>Medium scale integration : to 1971</p>
<ul>
<li>100-3,000 devices on a chip</li>
</ul>
</li>
<li>
<p>Large scale integration : 1971-1977</p>
<ul>
<li>3,000 - 100,000 devices on a chip</li>
</ul>
</li>
<li>
<p>Very large scale integration : 1978 -1991</p>
<ul>
<li>100,000 - 100,000,000 devices on a chip</li>
</ul>
</li>
<li>
<p>Ultra large scale integration : 1991 – now</p>
<ul>
<li>Over 100,000,000 devices on a chip</li>
</ul>
</li>
</ul>
<h4 id="technology-change">Technology Change</h4>
<ul>
<li>
<p>Hardware</p>
<ul>
<li>
<p>Vacuum tubes: Electron emitting devices</p>
</li>
<li>
<p>Transistors: On-off switches controlled by electricity</p>
</li>
<li>
<p>Integrated Circuits( IC/ Chips): Combines thousands of transistors</p>
</li>
<li>
<p>Very Large-Scale Integration( VLSI): Combines millions of transistors</p>
</li>
</ul>
</li>
<li>
<p>Software</p>
<ul>
<li>
<p>Machine language: Zeros and ones</p>
</li>
<li>
<p>Assembly language: Mnemonics</p>
</li>
<li>
<p>High-Level Languages: English-like</p>
</li>
</ul>
</li>
</ul>
<h4 id="core-memory">Core Memory</h4>
<ul>
<li>
<p>In the 1950s and 1960s, most computer memory was constructed from tiny rings of ferromagnetic material, each about a sixteenth of an inch in diameter</p>
</li>
<li>
<p>Core Memory: Cores are rings of ferrite suspended in a grid of wires</p>
</li>
<li>
<p>A charge to a point on the grid magnetizes the ring in a clockwise or counter-clockwise direction, which corresponds to a one or a zero: one bit</p>
</li>
<li>
<p>Able to retain information when the electricity is turned off because it holds its state</p>
</li>
<li>
<p>fast $(1us)$ but expensive, destructive readout</p>
</li>
</ul>
<h4 id="semiconductor-memory">Semiconductor Memory</h4>
<ul>
<li>
<p>1970 – semiconductor memory: higher density (size of a single core, 256 bits），non-destructive，much faster ,more expensive</p>
</li>
<li>
<p>1974 – the price per bit of semiconductor memory dropped below the price per bit of core memory. – since then, the cost continue decreasing, the density continue increasing</p>
</li>
<li>
<p>13 generations.：The capacity of a single chip has changed from $1K, 4K, 16K, 64K, 256K, 1M, 4M, 16M, 64M, 256M, 1G$ and $4G$. Now a single memory can reach $128G$</p>
</li>
</ul>
<hr>
<p><strong>Resulting New Developments – Microprocessors</strong></p>
<ul>
<li>
<p>Just as the density of elements on memory chips has continued to rise, so has the density of elements on processor chips</p>
</li>
<li>
<p>More and more elements placed on chip</p>
</li>
<li>
<p>1971—First microprocessor Intel 4004</p>
</li>
<li>
<p>1972—Next Intel 8008, the first 8-bit microprocessor</p>
</li>
<li>
<p>1974—Intel 8080，first general-purpose microprocessor. Faster, richer instruction sets, and has stronger addressing capabilities</p>
</li>
</ul>
<hr>
<p><strong>Intel Microprocessors</strong></p>
<ul>
<li>
<p>Later, 8086 was released in 1978 and 8088 was released in 1979. These two CPUs have been widely used</p>
</li>
<li>
<p>In the 1980s, Intel released 286，386，486，etc</p>
</li>
<li>
<p>In 1993, Pentium CPU was released, followed by Pentium 2.3</p>
</li>
<li>
<p>In 2006, dual core CPU was released</p>
</li>
<li>
<p>Intel has firmly occupied the processor market of desktop computers</p>
</li>
</ul>
<h3 id="designing-for-performance">Designing for Performance</h3>
<ul>
<li>
<p>Performance and storage capacity of the computer are constantly improving, and the price is constantly decreasing</p>
</li>
<li>
<p>Computers have been applied to all fields of life, and people&rsquo;s requirements for computers are getting higher and higher</p>
</li>
<li>
<p>Today, the applications require the great power of today’s microprocessor based</p>
<ul>
<li>
<p>Image processing</p>
</li>
<li>
<p>Speech recognition</p>
</li>
<li>
<p>Videoconferencing</p>
</li>
<li>
<p>etc……</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>The factors that affect a computer performance directly</strong>
<ul>
<li><strong>Microprocessor speed</strong></li>
<li><strong>Performance balance</strong></li>
<li><strong>Improvements in chip organization and architecture</strong></li>
</ul>
</li>
</ul>
<h4 id="microprocessor-speed">Microprocessor Speed</h4>
<blockquote>
<p>According to Moore&rsquo;s theorem, by integrating more transistors on the chip and reducing the distance between circuits, the performance of microprocessors can be improved by 4-5 times every three years</p>
</blockquote>
<ul>
<li>
<p>The processor designers must come up with ever more elaborate techniques for feeding a constant stream of work to do</p>
</li>
<li>
<p>Branch prediction</p>
</li>
<li>
<p>Data flow analysis</p>
</li>
<li>
<p>Speculative execution</p>
</li>
</ul>
<hr>
<h5 id="performance-gap-of-cpu-and-memory">Performance gap of CPU and memory</h5>
<p><strong>While CPU power has raced ahead at speed, other critical</strong> <strong>components have not kept up</strong></p>
<p><strong>! ! ! Performance of memory will seriously affect the performance of CPU!</strong></p>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-5.png" title="/img/Computer Organization and Architecture/chapter2-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-5.png" data-sub-html="<h2>Moore&#39;s Law</h2>">
        
    </a><figcaption class="image-caption"><code>Moore's Law</code></figcaption>
    </figure>
<h5 id="solutions-about-memory">Solutions about Memory</h5>
<ul>
<li>
<p><strong>Increase number of bits retrieved at one time</strong></p>
<ul>
<li>Make DRAM “wider” rather than “deeper”</li>
</ul>
</li>
<li>
<p><strong>Change DRAM interface</strong></p>
<ul>
<li>Cache</li>
</ul>
</li>
<li>
<p><strong>Reduce frequency of memory access</strong></p>
<ul>
<li>More complex cache and cache on chip</li>
</ul>
</li>
<li>
<p><strong>Increase interconnection bandwidth</strong></p>
<ul>
<li>
<p>High speed buses</p>
</li>
<li>
<p>Hierarchy of buses</p>
</li>
</ul>
</li>
</ul>
<h5 id="typical-io-device-data-rates">Typical I/O Device Data Rates</h5>
<ul>
<li>
<p>Same problem in I/O access</p>
</li>
<li>
<p>Lots of I/O device types</p>
</li>
<li>
<p>Large data rate difference</p>
</li>
</ul>
<h5 id="solutions-about-io-devices">Solutions about I/O devices</h5>
<ul>
<li>
<p>Caching</p>
</li>
<li>
<p>Buffering</p>
</li>
<li>
<p>Higher-speed interconnection buses</p>
</li>
<li>
<p>More elaborate bus structures</p>
</li>
<li>
<p>Multiple-processor configurations</p>
</li>
</ul>
<h5 id="key-factor-is-balance">Key factor is balance</h5>
<blockquote>
<p>Key to solving the problem of computer performance is to balance, that is, to find the best combination scheme among various components</p>
</blockquote>
<ul>
<li>
<p>Processor components</p>
</li>
<li>
<p>Main memory</p>
</li>
<li>
<p>I/O devices</p>
</li>
<li>
<p>Interconnection structures</p>
</li>
</ul>
<h4 id="process-speed">Process speed</h4>
<p><strong>Three approaches to achieving increased processor speed</strong></p>
<ul>
<li>
<p><strong>Increase hardware speed of processor</strong></p>
<ul>
<li>Fundamentally due to shrinking logic gate size</li>
</ul>
</li>
<li>
<p><strong>Increase size and speed of caches</strong></p>
<ul>
<li>Dedicating part of processor chip</li>
</ul>
</li>
<li>
<p><strong>Change processor organization and architecture</strong></p>
<ul>
<li>
<p>Increase effective speed of execution</p>
</li>
<li>
<p><strong>Parallelism</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="problems-with-clock-speed-and-logic-density">Problems with Clock Speed and Logic Density</h4>
<ul>
<li>
<p>Power</p>
<ul>
<li>
<p><strong>Power density increases with density of logic and clock speed</strong></p>
</li>
<li>
<p>Dissipating heat</p>
</li>
</ul>
</li>
<li>
<p>RC delay</p>
<ul>
<li>
<p>Delay increases as RC product increases</p>
</li>
<li>
<p>Wire interconnects thinner, increasing resistance</p>
</li>
<li>
<p>Wires closer together, increasing capacitance</p>
</li>
</ul>
</li>
<li>
<p>Memory latency</p>
<ul>
<li><strong>Memory speeds lag processor speeds</strong></li>
</ul>
</li>
</ul>
<h4 id="increasing-cache-capacity">Increasing cache capacity</h4>
<ul>
<li>
<p>Typically two or three levels of cache between processor and main memory</p>
</li>
<li>
<p>Chip density increased</p>
<ul>
<li>More cache memory on chip</li>
<li>Faster cache access</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Pentium chip devoted about 10% of chip area to cache</li>
<li>Pentium 4 devotes about 50%</li>
</ul>
</blockquote>
<h4 id="more-complex-execution-logic">More complex execution logic</h4>
<p><strong>Enable parallel execution of instructions</strong></p>
<ul>
<li>
<p>Pipeline works like assembly line</p>
<ul>
<li>Different stages of execution of different instructions at same time along pipeline</li>
</ul>
</li>
<li>
<p>Super-scalar allows multiple pipelines within single processor</p>
<ul>
<li>Instructions that do not depend on one another can be executed in parallel!</li>
</ul>
</li>
</ul>
<a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-6.png" title="/img/Computer Organization and Architecture/chapter2-6.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-6.png">
        
    </a>
<h4 id="diminishing-returns">Diminishing returns</h4>
<ul>
<li>
<p><strong>Internal organization of processors complex</strong></p>
<ul>
<li>
<p>Can get a great deal of parallelism</p>
</li>
<li>
<p>Further significant increases likely to be relatively modest</p>
</li>
</ul>
</li>
<li>
<p><strong>Benefits from cache are reaching limit</strong></p>
</li>
<li>
<p><strong>Increasing clock rate runs into power dissipation problem</strong></p>
<ul>
<li>Some fundamental physical limits are being reached</li>
</ul>
</li>
</ul>
<h4 id="new-approach--multiple-cores">New approach – multiple cores</h4>
<ul>
<li>
<p><strong>Multiple processors on single chip</strong></p>
<ul>
<li><strong>Large shared cache</strong></li>
</ul>
</li>
<li>
<p><strong>Within a processor, increase in performance proportional to square root of increase in complexity</strong></p>
</li>
<li>
<p><strong>If software can use multiple processors, doubling number of processors almost doubles performance</strong></p>
</li>
</ul>
<h4 id="cisc-and-risc"><code>CISC</code> and <code>RISC</code></h4>
<ul>
<li>
<p><strong>The Intel x86 represents the complex instruction set computers<code>(CISC)</code></strong></p>
<ul>
<li>
<p>Personal computer</p>
</li>
<li>
<p>Mainframes</p>
</li>
<li>
<p>Supercomputers</p>
</li>
</ul>
</li>
<li>
<p><strong>The ARM architecture represents the reduced instruction set computers <code>(RISC)</code></strong></p>
<ul>
<li>
<p>SUN SPARC，MIPS</p>
</li>
<li>
<p>Apple Macintosh</p>
</li>
<li>
<p>embedded chip</p>
</li>
<li>
<p>Mobile phone</p>
</li>
</ul>
</li>
</ul>
<h3 id="performance-assessment">Performance Assessment</h3>
<p><strong>About Performance Assessment</strong></p>
<ul>
<li>
<p>Evaluating the performance of different processor is difficult because of different architectures used</p>
<ul>
<li>
<p>One processor is suitable for specific scenario</p>
</li>
<li>
<p>Instruction set, program language, compiler have an impact on the performance of processors</p>
</li>
</ul>
</li>
<li>
<p>How to evaluate the performance of the processor?</p>
</li>
</ul>
<hr>
<h4 id="system-clock">System clock</h4>
<ul>
<li>
<p><strong>System clock speed</strong></p>
<ul>
<li>
<p>Related to execution time of Instruction</p>
</li>
<li>
<p>Generated by the crystal oscillator，after analog-to-digital conversion, forms a digital voltage pulse signal</p>
</li>
</ul>
</li>
<li>
<p><strong>In Hz or multiples of</strong></p>
</li>
<li>
<p><strong>Clock rate, clock cycle, clock tick, cycle time</strong></p>
</li>
</ul>
<h4 id="clock-speed">Clock speed</h4>
<ul>
<li>
<p><strong>Operations need to be synchronized</strong></p>
</li>
<li>
<p>Instruction execution <strong>in discrete steps</strong></p>
<ul>
<li>
<p><strong>Fetch, decode, load and store, arithmetic or logical</strong></p>
</li>
<li>
<p>Usually require multiple clock cycles per instruction</p>
</li>
</ul>
</li>
<li>
<p><strong>Instruction is not fully serial</strong></p>
</li>
<li>
<p><strong>Pipelining gives simultaneous execution of instructions</strong></p>
</li>
<li>
<p>So, clock speed is not the whole story</p>
</li>
</ul>
<h4 id="instruction-execution-rate---">Instruction execution rate ! ! !</h4>
<ul>
<li>
<p><strong>MIPS: Million Instruction per Second</strong></p>
</li>
<li>
<p><strong>CPI，Cycle per Instruction</strong></p>
</li>
<li>
<p><strong>CPU constant frequency $f\newline$</strong></p>
</li>
<li>
<p><strong>constant cycle time $T=\frac{1}{f}\newline$</strong></p>
</li>
<li>
<p><strong>Instruction count $Ic\newline$</strong></p>
</li>
<li>
<p><strong>CPI</strong></p>
</li>
</ul>
<p>$$
CPI=\frac{\sum_{i=1}^n(CPI_i \times I_i)}{I_c}\newline
$$</p>
<p><strong>Parameter in CPI</strong></p>
<ul>
<li>$I_c$: The number of machine instructions executed for that program, not the number of instructions in the object code of the program</li>
<li>$CPI_i$ be the number of cycles required for instruction type i</li>
<li>$I_i$ be the number of executed instructions of type i for a given program</li>
<li>The processor time T needed to execute a given program can be expressed as</li>
</ul>
<p>$$
T=I_c \times CPI \times T\newline
$$</p>
<ul>
<li>A processors driven by a clock with a constant frequency f or,equivalently, a constant cycle time , where</li>
</ul>
<p>$$
T=\frac{1}{f}\newline
$$</p>
<hr>
<ul>
<li><strong>MIPS</strong></li>
</ul>
<p>$$
MIPS_{rate}=\frac{I_c}{T \times 10^6}=\frac{f}{CPI \times 10^6}\newline
$$</p>
<ul>
<li><strong>MFLOPS</strong></li>
</ul>
<p>$$
MFLOPS=\frac{Number\ of\ floating-point\ operations\ in\ the\ program}{Execute\ time \times 10^6}\newline
$$</p>
<ul>
<li>
<p>Millions of floating point instructions per second <code>(MFLOPS)</code></p>
</li>
<li>
<p><strong>Heavily dependent on instruction set, compiler design, processor implementation, cache &amp; memory hierarchy</strong></p>
</li>
</ul>
<hr>
<p><strong>Example 1</strong></p>
<table>
<thead>
<tr>
<th><strong>Type of instruction</strong></th>
<th><strong>number of instructions</strong></th>
<th><strong>The number of clock cycles for the instruction</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>integer arithmetic</strong></td>
<td>50000</td>
<td>1</td>
</tr>
<tr>
<td><strong>floating point arithmetic</strong></td>
<td>20000</td>
<td>3</td>
</tr>
<tr>
<td><strong>data transfer</strong></td>
<td>25000</td>
<td>2</td>
</tr>
<tr>
<td><strong>control instruction</strong></td>
<td>5000</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>$$
CPI=\frac{50000 \times 1 + 20000 \times 3 + 25000 \times 2 + 5000 \times 2}{50000+20000+25000+5000}=1.7\newline
$$</p>
<p><strong>Example 2</strong></p>
<p>A computer with a main frequency of 100 MHz performs a section of the program. The number and cycles of various instructions in the program are shown in the table below. Calculate the CPI of this procedure as well as the MIPS</p>
<table>
<thead>
<tr>
<th><strong>Type of instruction</strong></th>
<th><strong>number of instructions</strong>(M)</th>
<th><strong>The number of clock cycles for the instruction</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arithmetic and logical operations</strong></td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td><strong>data access</strong></td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td><strong>control instruction</strong></td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td><strong>other</strong></td>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>$$
\begin{align}
&amp;CPI=\frac{5 \times 1 + 8 \times 2 + 2 \times 4 + 1 \times 3}{5 + 8 + 2 + 1}=2\newline
&amp;MIPS=\frac{f}{CPI \times 10^6}=\frac{100 \times 10 ^6}{2 \times 10^6}=50\newline
\end{align}
$$</p>
<h4 id="benchmarks">Benchmarks</h4>
<p>Benchmarks: Programs designed to test performance</p>
<ul>
<li>
<p><strong>Written in high level language</strong></p>
<ul>
<li><strong>Portable</strong></li>
</ul>
</li>
<li>
<p><strong>Represents style of task</strong></p>
<ul>
<li>Systems, numerical, commercial</li>
</ul>
</li>
<li>
<p>Easily measured</p>
</li>
<li>
<p>Widely distributed</p>
</li>
<li>
<p>System Performance Evaluation Corporation</p>
</li>
<li>
<p>Most famous: SPEC 2006</p>
<ul>
<li>
<p>Suitable for testing applications of computing intensive</p>
</li>
<li>
<p>17 floating-point programs written in C, C++ and FORTRAN</p>
</li>
<li>
<p>12 integer programs written in C and C++</p>
</li>
<li>
<p>total code of more than 3 million lines</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="result-process-and-analysis--">Result process and analysis! ! !</h5>
<ul>
<li>
<p>Run several different test programs, and then arithmetically process the test results to obtain an average measurement</p>
</li>
<li>
<p>Average execution speed</p>
</li>
</ul>
<p>$$
R_A=\frac{1}{m} \sum_{i=1}^m R_i\newline
R_i \rightarrow the\ execution\ speed\ of\ the\ high-level\ language\ instructions\ of\ the\ i^{th}\ benchmark\ program\newline
$$</p>
<ul>
<li>Harmonic mean</li>
</ul>
<p>$$
R_B=\frac{m}{\sum_{i=1}^m \frac{1}{R_i}}\newline
\frac{1}{R_i} \rightarrow Average\ instruction\ execution\ time\ for\ the\ i^{th}\ baseline\ procedure\newline
$$</p>
<h5 id="speed-metric---">Speed Metric ! ! !</h5>
<ul>
<li>
<p><strong>Ability of a computer to complete a single task</strong></p>
</li>
<li>
<p>$r_i=\frac{T_{left}}{T_{suti}}\newline$</p>
</li>
<li>
<p>$T_{left}$: execution time of benchmark program i on the reference system</p>
</li>
<li>
<p>$T_{suti}$: execution time of benchmark program i on the system under test</p>
</li>
<li>
<p>Use geometric mean for more than one benchmark program $\rightarrow r_G=(\prod_{i=1}^n r_i)^{\frac{1}{n}}\newline$</p>
</li>
</ul>
<p><strong>Example 3</strong></p>
<p>According to the following conditions, compare the performance of the two processors by two methods (the average execution speed and the harmonic average) and analyze the significance</p>
<table>
<thead>
<tr>
<th>benchmark</th>
<th>The MIPS for the processor 1</th>
<th>The MIPS for the processor 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>benchmark 1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>benchmark 2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>benchmark 3</td>
<td>5</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>$$
\begin{align}
&amp;The\ average\ execution\ speed\newline
&amp;benchmark_1=\frac{2+3+5}{3}=\frac{10}{3}\newline
&amp;benchmark_2=\frac{3+4+5}{3}=\frac{10}{3}\newline
&amp;The\ harmonic\ average\newline
&amp;benchmark_1=\frac{3}{\frac{1}{2}+\frac{1}{3}+\frac{1}{5}}=\frac{90}{31}\newline
&amp;benchmark_2=\frac{3}{\frac{1}{3}+\frac{1}{4}+\frac{1}{3}}=\frac{36}{11}\newline
\end{align}
$$</p>
<p><strong>Processor 2 has better performance</strong></p>
<h4 id="amdahls-law---">Amdahl’s Law ! ! !</h4>
<ul>
<li>
<p>First proposed by Gene Amdahl</p>
</li>
<li>
<p>For program running on single processor and multi processors</p>
<ul>
<li>
<p>Fraction <em>f</em> of code infinitely parallelizable with no scheduling overhead</p>
</li>
<li>
<p>Fraction (1-<em>f</em>) of code inherently serial</p>
</li>
<li>
<p>T is total execution time for program on single processor</p>
</li>
<li>
<p>N is number of processors that fully exploit parallel portions of code</p>
</li>
</ul>
</li>
</ul>
<p>$$
Speedup=\frac{time\ to\ execute\ program\ on\ a\ single\ processor}{time\ to\ execute\ program\ on\ N\ parallel\ processors}=\frac{T(1-f)+Tf}{T(1-f)+\frac{Tf}{N}}=\frac{1}{(1-f)+\frac{f}{N}}\newline
$$</p>
<h5 id="conclusions-of-amdahls-law---">Conclusions of Amdahl’s Law ! ! !</h5>
<ul>
<li>
<p><strong>f small, parallel processors has little effect</strong></p>
</li>
<li>
<p>$N \rightarrow \infty$,speedup bound by $\frac{1}{1-f}\newline$</p>
<ul>
<li><em>Diminishing returns for using more processors</em></li>
</ul>
</li>
</ul>
<p>$$
Speedup=\frac{1}{(1-f)+\frac{f}{SU_f}}\newline
$$</p>
<p><strong>Example 5</strong></p>
<ul>
<li>Assuming 20% of the program, what is the ideal speed-up ratio for an 8-core processor?</li>
</ul>
<p>$$
Speedup=\frac{1}{0.2+\frac{0.8}{8}}=3.33\newline
$$</p>
<ul>
<li>A 4-core processor, if you want to accelerate to a ratio of no less than 3, needs at least what proportion of the instructions that can be executed in parallel</li>
</ul>
<p>$$
3=\frac{1}{(1-f)+\frac{f}{N}}\newline
f=\frac{8}{9}\newline
$$</p>
<h4 id="intel-x86-and-arm-processor-families"><code>Intel x86</code> and <code>ARM</code> processor families</h4>
<h5 id="intel"><code>Intel</code></h5>
<ul>
<li>
<p>1971-4004</p>
<ul>
<li>
<p>First microprocessor</p>
</li>
<li>
<p>All CPU components on a single chip</p>
</li>
<li>
<p>4 bit</p>
</li>
</ul>
</li>
<li>
<p>Followed in 1972 by 8008</p>
<ul>
<li>
<p>8 bit</p>
</li>
<li>
<p>Both designed for specific applications</p>
</li>
</ul>
</li>
<li>
<p>1974 - 8080</p>
<ul>
<li>
<p>Intel’s first general purpose microprocessor</p>
</li>
<li>
<p>8 bit data path</p>
</li>
<li>
<p>Used in first personal computer – Altair</p>
</li>
</ul>
</li>
</ul>
<h5 id="intel-x86history"><code>Intel x86</code>(history)</h5>
<ul>
<li>
<p>1978-8086</p>
<ul>
<li>
<p>$5MHz\newline$</p>
</li>
<li>
<p>29000 transistors</p>
</li>
<li>
<p>much more powerful</p>
</li>
<li>
<p>16 bit</p>
</li>
<li>
<p>instruction cache, pre-fetch few instructions</p>
</li>
</ul>
</li>
<li>
<p>1982-80286</p>
<ul>
<li>
<p>16 Mbyte memory addressable</p>
</li>
<li>
<p>up from 1GB</p>
</li>
</ul>
</li>
<li>
<p>1985-80386</p>
<ul>
<li>
<p>32 bit</p>
</li>
<li>
<p>Support for multitasking</p>
</li>
</ul>
</li>
<li>
<p>1989-80486</p>
<ul>
<li>
<p>sophisticated powerful cache and instruction pipelining</p>
</li>
<li>
<p>Built-in maths co-processor</p>
</li>
</ul>
</li>
<li>
<p>1993-Pentium</p>
<ul>
<li>
<p>Superscalar</p>
</li>
<li>
<p>Multiple instructions executed in parallel</p>
</li>
</ul>
</li>
<li>
<p>1995-Pentium Pro</p>
<ul>
<li>
<p>Increased superscalar organization</p>
</li>
<li>
<p>Aggressive register renaming 寄存器重命名</p>
</li>
<li>
<p>branch prediction</p>
</li>
<li>
<p>data flow analysis</p>
</li>
<li>
<p>speculative execution</p>
</li>
</ul>
</li>
<li>
<p>1997-Pentium II</p>
<ul>
<li>
<p><code>MMX</code> technology</p>
</li>
<li>
<p>graphics, video &amp; audio processing</p>
</li>
</ul>
</li>
<li>
<p>1999-Pentium III</p>
<ul>
<li>Additional floating point instructions for 3D graphics</li>
</ul>
</li>
<li>
<p>2000-Pentium 4</p>
<ul>
<li>
<p>42 Million transistors</p>
</li>
<li>
<p>Further floating point and multimedia enhancements</p>
</li>
</ul>
</li>
<li>
<p>2006-Core 2 Duo</p>
<ul>
<li>
<p>First <code>x86</code> with dual core</p>
</li>
<li>
<p>64 bit architecture</p>
</li>
</ul>
</li>
<li>
<p>2008-Core 2 Quad – <code>3GHz</code> – 820 million transistors</p>
<ul>
<li>Four processors on chip</li>
</ul>
</li>
<li>
<p>i7、i5、i3……</p>
</li>
<li>
<p><code>x86</code> architecture dominant outside embedded systems</p>
</li>
<li>
<p>Instruction set architecture evolved with backwards compatibility</p>
</li>
</ul>
<h4 id="what-is-embedded-system">What is embedded system?</h4>
<ul>
<li>
<p>An embedded system is a special-purpose computer system designed to perform one or a few dedicated functions, often with real-time computing constraints</p>
</li>
<li>
<p>It is usually <em>embedded</em> as part of a complete device including hardware and mechanical parts</p>
</li>
<li>
<p>Complexity varies from low, with a single micro-controller chip, to very high with multiple units, peripherals and networks mounted inside a large enclosure</p>
</li>
</ul>
<h5 id="requirements-of-embedded-system">Requirements of embedded system</h5>
<ul>
<li>
<p>Different sizes</p>
<ul>
<li>Different constraints, optimization, reuse</li>
</ul>
</li>
<li>
<p>Different requirements</p>
<ul>
<li>
<p>Safety, reliability, real-time, flexibility, legislation</p>
</li>
<li>
<p>Lifespan</p>
</li>
<li>
<p>Environmental conditions</p>
</li>
<li>
<p>Static or dynamic loads</p>
</li>
<li>
<p>Slow to fast speeds</p>
</li>
<li>
<p>Computation or I/O intensive</p>
</li>
</ul>
</li>
</ul>
<h4 id="possible-organization">Possible organization</h4>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter2-7.png" title="/img/Computer Organization and Architecture/chapter2-7.png" data-thumbnail="/img/Computer Organization and Architecture/chapter2-7.png" data-sub-html="<h2>Possible organization</h2>">
        
    </a><figcaption class="image-caption"><code>Possible organization</code></figcaption>
    </figure>
<h4 id="arm-evolution">ARM Evolution</h4>
<ul>
<li>
<p><strong>ARM: Advanced RISC Machine</strong></p>
</li>
<li>
<p>Designed by ARM Inc., Cambridge, England</p>
</li>
<li>
<p>Licensed to manufacturers</p>
</li>
<li>
<p><strong>High speed, low power consumption</strong></p>
</li>
<li>
<p><strong>PDAs, hand held games, phones PDA</strong></p>
<ul>
<li><strong>E.g. iPad, iPhone</strong></li>
</ul>
</li>
</ul>
<h3 id="computer-types">Computer Types</h3>
<ul>
<li>
<p><strong>Microcomputers</strong></p>
</li>
<li>
<p><strong>Mainframes</strong></p>
</li>
<li>
<p><strong>Supercomputers</strong></p>
</li>
</ul>
<h4 id="microcomputer">Microcomputer</h4>
<ul>
<li>
<p><em>microcomputer</em> is generally synonymous with:</p>
<ul>
<li>
<p>personal computer (PC)</p>
</li>
<li>
<p>A computer that depends on a microprocessor</p>
</li>
</ul>
</li>
<li>
<p>Designed to be used by individuals:</p>
<ul>
<li>
<p>PCs</p>
</li>
<li>
<p>Workstations</p>
</li>
<li>
<p>Notebook computers</p>
</li>
</ul>
</li>
</ul>
<h4 id="workstation">Workstation</h4>
<ul>
<li>
<p>A workstation is a high-end microcomputer designed for technical or scientific applications</p>
</li>
<li>
<p>The term <em>workstation</em> has also been used to <strong>refer to a mainframe computer terminal or a PC connected up to a network</strong></p>
</li>
<li>
<p>Historically, workstations had offered higher performance than personal computers, especially with respect to graphics and CPU power, memory capacity and multitasking ability</p>
</li>
</ul>
<h4 id="mainframe">Mainframe</h4>
<blockquote>
<p>The chief difference between a supercomputer and a mainframe is that a supercomputer channels all its power into executing a few programs as fast as possible, whereas a mainframe uses its power to execute many programs concurrently</p>
</blockquote>
<h3 id="important-terminology---">Important terminology ! ! !</h3>
<ul>
<li>
<p>Bit: a binary digit that can have value 0 or 1</p>
</li>
<li>
<p>Byte: defined as 8 bits</p>
</li>
<li>
<p>Word: a set of bits constituting the smallest unit of addressable memory</p>
</li>
<li>
<p>KB:  $2^{10}$ bytes (1024 bytes)</p>
</li>
<li>
<p>MB: $2^{20}$ bytes</p>
</li>
<li>
<p>GB:  $2^{30}$ bytes</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Computer Organization and Architecture Introduction</title>
    <link>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-introduction/</link>
    <pubDate>Tue, 10 Jan 2023 22:17:58 &#43;0800</pubDate><author>1239946358@qq.com (Jungle)</author><guid>https://Jungle430.github.io/posts/computer-organization-and-architecture/computer-organization-and-architecture-introduction/</guid>
    <description><![CDATA[<h1 id="computer-organization-and-architecture">Computer Organization and Architecture</h1>
<h2 id="introduction">Introduction</h2>
<h3 id="content">content</h3>
<p>It includes two parts: <strong>computer composition principle</strong> and <strong>computer architecture</strong></p>
<ul>
<li>
<p>The principle of composition mainly discusses the various components of computer systems and their working mechanisms</p>
</li>
<li>
<p>Architecture studies computer instruction sets, I/O mechanisms, addressing techniques, and more</p>
</li>
</ul>
<h3 id="preface">Preface</h3>
<p><strong>The characteristics of this course:</strong></p>
<ul>
<li>
<p>core basic course of computer major</p>
</li>
<li>
<p>Fundamental</p>
</li>
<li>
<p>Abstractness</p>
</li>
<li>
<p>Modularization</p>
</li>
<li>
<p>Relevance</p>
</li>
<li>
<p>Hierarchy</p>
</li>
<li>
<p>One of the required subjects for postgraduate entrance examination</p>
</li>
</ul>
<h3 id="outline">Outline</h3>
<ul>
<li>
<p>Introduction of Computer and this course</p>
</li>
<li>
<p>Why Study Computer Organization and Architecture?</p>
</li>
<li>
<p>Organization and Architecture</p>
</li>
<li>
<p>Structure and Function</p>
</li>
</ul>
<h3 id="introduction-of-computer-and-this-course">Introduction of Computer and this course</h3>
<h4 id="main-parts-of-the-computer">Main parts of the computer</h4>
<ul>
<li>
<p>Network card</p>
</li>
<li>
<p>sound card</p>
</li>
<li>
<p>GPU</p>
</li>
<li>
<p>memory</p>
</li>
<li>
<p>CPU</p>
</li>
<li>
<p>air fan</p>
</li>
<li>
<p>mainboard (motherboard)</p>
</li>
<li>
<p>Data line</p>
</li>
<li>
<p>Optical Disk Driver</p>
</li>
<li>
<p>Hard disk</p>
</li>
<li>
<p>floppy disk drive</p>
</li>
</ul>
<h4 id="computing-devices-then">Computing devices then</h4>
<h5 id="edsac">EDSAC</h5>
<p>$EDSAC$: <strong>Electronic Delay Storage Automatic Calculator</strong>,University of Cambridge, UK, 1949</p>
<ul>
<li>
<p><strong>First stored program</strong></p>
</li>
<li>
<p>About 3000 vacuum tubes ，arranged on 12 cabinets, covering an area of 5 × 4 meters</p>
</li>
<li>
<p>Power consumption 12 kW</p>
</li>
<li>
<p><strong>Consists of five parts: arithmetic unit (ALU), controller, memory, input and output</strong></p>
</li>
<li>
<p>About 650 instructions per second</p>
</li>
</ul>
<h4 id="rapid-change-of-underlying-technology">Rapid Change of Underlying Technology</h4>
<blockquote>
<p>With the continuous improvement of the integration of <strong>integrated circuits</strong>, more components can be packed into chips of the same size</p>
</blockquote>
<p>Computers becomes</p>
<ul>
<li>
<p>Performance ：faster</p>
</li>
<li>
<p>Memory capacity ：larger</p>
</li>
<li>
<p>Volume ：smaller</p>
</li>
</ul>
<p>Computer technology</p>
<ul>
<li>
<p>Integrated circuit technology</p>
</li>
<li>
<p>Parallel organization</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<h4 id="development-trend-of-computer">Development trend of computer</h4>
<p>$Gordon\ Moore, Electronics, 1965\newline$</p>
<p>$\downarrow \downarrow \downarrow \downarrow\newline$</p>
<ul>
<li>
<p>Number of <em>transistor on the chip</em> <strong>doubles every certain time</strong></p>
</li>
<li>
<p>Processor performance is getting <strong>stronger and smaller</strong></p>
</li>
</ul>
<h4 id="content-of-this-course">Content of this course</h4>
<div class="mermaid" id="id-1"></div>
<h4 id="how-does-computer-work">How does computer work?</h4>
<ul>
<li>How does a basic instruction execute in CPU?</li>
</ul>
<p>Example $\rightarrow$​ <strong>Add R1, R2</strong> (add content of <code>R1</code> and content of <code>R2</code>, place result in <code>R1</code>)</p>
<h5 id="execution-steps-of-add-r1r2">Execution steps of Add R1,R2</h5>
<p>The “possible” micro-execution steps are:</p>
<ol>
<li>
<p>$ALU_1 \leftarrow\ [R1]$				{content of R1 is moved to ALU1 }</p>
</li>
<li>
<p>$ALU_2 \leftarrow [R2]$                 {content of R2 is moved to ALU2 }</p>
</li>
<li>
<p>$ADD$                                 {content of ALU1 + ALU2 = ALU3 }</p>
</li>
<li>
<p>$R1 \leftarrow [ALU_3]$                 {Result of addition is moved to R1}</p>
</li>
</ol>
<p>If, each micro-step is executed in “one” clock-cycle, then  this Add instruction <strong>needs 4 clock-cycles</strong></p>
<h5 id="how-to-reduce-execution-time">How to reduce execution time?</h5>
<ul>
<li>
<p>Need 4 clock-cycles</p>
</li>
<li>
<p>Data transfer takes 75% of the time (1, 2, 4)</p>
</li>
<li>
<p>With single bus, it is slow, since in each “clock” only one transfer could be executed</p>
</li>
</ul>
<hr>
<ul>
<li>Is there any other way to “improve” the speed?
<ul>
<li>Dual bus processor may be faster</li>
<li>Additional processor cost</li>
</ul>
</li>
</ul>
<h6 id="dual-bus-processor">Dual bus processor</h6>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter1-1.png" title="/img/Computer Organization and Architecture/chapter1-1.png" data-thumbnail="/img/Computer Organization and Architecture/chapter1-1.png" data-sub-html="<h2>Solve(Dual bus processor)</h2>">
        
    </a><figcaption class="image-caption">Solve(<code>Dual bus processor</code>)</figcaption>
    </figure>
<h5 id="how-about-cpu-memory-connection"><strong>How about CPU-Memory Connection?</strong></h5>
<p><strong>Problem:</strong></p>
<ul>
<li>
<p>CPU can transfer 16/32/64 bit data or instruction (from one CPU unit to another) in <strong>less than one nanosecond</strong>$ (for\ CPU\ with &gt; 1\ Ghz\ clock) \newline$</p>
</li>
<li>
<p>Memory unit/system, transfers 16/32/64 bit data or instruction in 40 to 60 nanoseconds (for memory w/40-60 nanosecond cycle time)</p>
</li>
</ul>
<p><strong>CPU has to wait more than 50 CPU clocks</strong>, waiting for data/instruction from memory to be available</p>
<hr>
<p><strong>Solve the problem:</strong></p>
<ul>
<li>We can overcome (partly) the CPU-Memory bottleneck by inserting cache memory between CPU and Main Memory</li>
</ul>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter1-2.png" title="/img/Computer Organization and Architecture/chapter1-2.png" data-thumbnail="/img/Computer Organization and Architecture/chapter1-2.png" data-sub-html="<h2>Solve(Cache)</h2>">
        
    </a><figcaption class="image-caption">Solve(<code>Cache</code>)</figcaption>
    </figure>
<p><strong>Other way to improve speed</strong></p>
<ul>
<li>
<p>Is there any other way to improve instruction execution speed (increasing performance)? <strong>Pipelining</strong></p>
</li>
<li>
<p>Are these improvements need extra cost? $(cost\ vs\ performance\ issue)\newline$</p>
</li>
<li>
<p>Balance</p>
</li>
</ul>
<h4 id="main-content-of-this-course">Main content of this course</h4>
<ul>
<li>
<p>PART ONE: OVERVIEW</p>
</li>
<li>
<p>PART TWO: THE COMPUTER SYSTEM</p>
</li>
<li>
<p>PART THREE: THE CENTRAL PROCESSING UNIT</p>
</li>
<li>
<p>PART FOUR: THE CONTROL UNIT</p>
</li>
<li>
<p>PART FIVE: PARALLEL ORGANIZATION</p>
</li>
</ul>
<h3 id="why-study-computer-organization-and-architecture">Why Study Computer Organization and Architecture?</h3>
<h4 id="in-this-course-we-will-learn">In this course, we will learn</h4>
<ul>
<li>
<p>What parts does the computer consist of?</p>
</li>
<li>
<p>How does each part work?</p>
</li>
<li>
<p>How are these parts connected?</p>
</li>
<li>
<p>What are the key factors affecting computer performance?</p>
</li>
<li>
<p>What methods are used to improve the performance of the computer?</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<ul>
<li>
<p>Balance</p>
<ul>
<li>
<p>Inserting cache memory</p>
</li>
<li>
<p>Selection of the number of registers: not only enough, but also not too many</p>
</li>
<li>
<p>cost vs performance</p>
</li>
</ul>
</li>
<li>
<p>Parallel</p>
<ul>
<li>
<p>Internal of CPU: pipeline, superscalar</p>
</li>
<li>
<p>On chip: multicore</p>
</li>
<li>
<p>Internal of machine: SMP,NUMA</p>
</li>
<li>
<p>Multi-machine: cluster</p>
</li>
</ul>
</li>
</ul>
<h4 id="after-this-course-we-will-know">After this course, we will know</h4>
<ul>
<li>
<p>We are able to analyze the inter relation among design of instructions, its implementation in a processor and the performance issues</p>
</li>
<li>
<p>Learn about the computer design and organization issues, namely hardware of a computer</p>
</li>
</ul>
<h4 id="what-is-the-context-of-this-course">What is the context of this course?</h4>
<p>$UML\newline$</p>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter1-3.png" title="/img/Computer Organization and Architecture/chapter1-3.png" data-thumbnail="/img/Computer Organization and Architecture/chapter1-3.png" data-sub-html="<h2>course(UML)</h2>">
        
    </a><figcaption class="image-caption">course(<code>UML</code>)</figcaption>
    </figure>
<h4 id="significance-of-this-course">Significance of this course</h4>
<ul>
<li>
<p>The computer lies at the heart of computing. Without it most of the computing disciplines today would be a branch of theoretical mathematics</p>
</li>
<li>
<p>To be a professional in any field of computing today, one should not regard the computer as just a black box that executes programs by magic</p>
</li>
<li>
<p>All students of computing should acquire some understanding and appreciation of a computer system’s functional components, their characteristics, their performance, and their interactions. There are practical implications as well</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>We need to understand computer architecture in order to structure a program so that it runs more efficiently on a real machine</p>
</li>
<li>
<p>In selecting a system to use, we should to able to understand the tradeoff among various components, such as CPU clock speed vs. memory size</p>
</li>
</ul>
<h4 id="role-of-the-computer-architect">Role of the computer architect</h4>
<ul>
<li>
<p>Look backward : examine old code</p>
</li>
<li>
<p>Look forward : Listen to the dreamers</p>
</li>
<li>
<p>Look Up : Nature of the problems</p>
</li>
<li>
<p>Look down : predict the future of the technology</p>
</li>
</ul>
<h3 id="organization-and-architecture">Organization and Architecture</h3>
<h4 id="architecture">Architecture</h4>
<ul>
<li>
<p><strong>Architecture is those attributes visible to the programmer</strong></p>
<ul>
<li>
<p><strong>Instruction set , number of bits used for data representation, I/O mechanisms, addressing techniques</strong></p>
</li>
<li>
<p>e.g. Is there a multiply instruction?</p>
</li>
<li>
<p>How best is memory handled by the OS?</p>
</li>
</ul>
</li>
</ul>
<h4 id="organization">Organization</h4>
<ul>
<li>
<p><strong>Organization is how features are implemented</strong></p>
</li>
<li>
<p><strong>Control signals, interfaces, memory technology</strong></p>
</li>
<li>
<p>e.g. Is there a hardware multiply unit or is it done by repeated addition?</p>
</li>
<li>
<p>What type of non-volatile memory is used to store the BIOS?</p>
</li>
</ul>
<h4 id="importance-of-the-distinction">Importance of the distinction</h4>
<ul>
<li>
<p><strong>A family of computer models: All with the same architecture but with differences in organization</strong></p>
<ul>
<li>
<p>The different models in the family have different price and performance characteristics</p>
</li>
<li>
<p>The organization of a particular architecture changing with changing technology</p>
</li>
</ul>
</li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li>
<p>All Intel x86 family share the same basic architecture</p>
</li>
<li>
<p>The IBM System/370 family share the same basic architecture</p>
</li>
<li>
<p>This gives code compatibility at least backwards</p>
</li>
<li>
<p>Organization differs between different versions</p>
</li>
</ul>
<h4 id="definition-of-architecture">Definition of architecture</h4>
<h5 id="traditional-definitionisa-only">Traditional definition——ISA-only</h5>
<blockquote>
<p>The term <strong>architecture</strong> is used here to describe the attributes of a system as seen by the programmer, i.e., the conceptual structure and functional behavior as distinct from the organization of the dataflow and controls, the logic design, and the physical implementation	<em>——Gene Amdahl</em>, IBM Journal of R&amp;D, April 1964</p>
</blockquote>
<h5 id="isa--implementation">ISA + implementation</h5>
<blockquote>
<p>The science and art of designing, selecting, and interconnecting hardware components and designing the hardware/software interface to create a computing system that meets functional, performance, energy consumption, cost, and other specific goals</p>
</blockquote>
<h4 id="organization-and-hardware">Organization and Hardware</h4>
<ul>
<li>
<p>Operation units and their interconnection to realize structural specifications</p>
<ul>
<li>
<p>Internal CPU,including Arithmetic, logic, branch, data transfer are implemented</p>
</li>
<li>
<p>Memory system</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>Hardware used to refer to specific of a machine</p>
<ul>
<li>
<p>Detailed logic design</p>
</li>
<li>
<p>Packaging technology of machine</p>
</li>
</ul>
</li>
</ul>
<h3 id="structure-and-function">Structure and Function</h3>
<h4 id="hierarchical-thought">Hierarchical thought</h4>
<ul>
<li>
<p>The modern computer uses the hierarchical to design, and the hierarchical characteristics are the basis of designing and describing them</p>
</li>
<li>
<p>In each layer, the system consists of a set of components and their interrelations</p>
</li>
<li>
<p>The behavior of each layer only depends on the simpler abstract features of the next layer of the system</p>
</li>
<li>
<p>Designers care about the structure and function of each layer</p>
</li>
</ul>
<h4 id="hierarchical-method---bottom-up">Hierarchical method - Bottom up</h4>
<blockquote>
<p>Bottom up: build a complete description from the bottom up. It starts from the most basic part of the system implementation, from simple to complex, build up layer by layer, until finally get the required system</p>
</blockquote>
<h4 id="hierarchical-method--top-down">Hierarchical method – Top down</h4>
<blockquote>
<p>Top down: starting from the top level, decompose the system into several sub parts. The essence is to decompose complex big problems into relatively simple small problems, find out the key and key points of each problem, and then describe the problem qualitatively and quantitatively with accurate thinking. Its core essence is &ldquo;decomposition&rdquo;</p>
</blockquote>
<p><strong>Top-down approach is the clearest and most effective.</strong></p>
<h4 id="structure--function">Structure &amp; Function</h4>
<ul>
<li>
<p>Structure is the way in which components relate to each other</p>
</li>
<li>
<p>Function is the operation of individual components as part of the structure</p>
</li>
</ul>
<h5 id="function">Function</h5>
<p>All computer functions are</p>
<ul>
<li>
<p>Data processing</p>
</li>
<li>
<p>Data storage</p>
</li>
<li>
<p>Data movement</p>
</li>
<li>
<p>Control</p>
</li>
</ul>
<h6 id="function-view">Function View</h6>
<div class="mermaid" id="id-2"></div>
<p><strong>Operation type 1 — data movement</strong></p>
<div class="mermaid" id="id-3"></div>
<p><strong>Operation type 2 — storage</strong></p>
<div class="mermaid" id="id-4"></div>
<p><strong>Operation type 3 — processing from/to storage</strong></p>
<div class="mermaid" id="id-5"></div>
<p><strong>Operation type 4 — processing from storage to I/O</strong></p>
<div class="mermaid" id="id-6"></div>
<h4 id="structure---top-level">Structure - Top level</h4>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter1-4.png" title="/img/Computer Organization and Architecture/chapter1-4.png" data-thumbnail="/img/Computer Organization and Architecture/chapter1-4.png" data-sub-html="<h2>Structure(Top Level)</h2>">
        
    </a><figcaption class="image-caption">Structure(<code>Top Level</code>)</figcaption>
    </figure>
<h4 id="structure---cpu">Structure - CPU</h4>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter1-5.png" title="/img/Computer Organization and Architecture/chapter1-5.png" data-thumbnail="/img/Computer Organization and Architecture/chapter1-5.png" data-sub-html="<h2>Structure(CPU)</h2>">
        
    </a><figcaption class="image-caption">Structure(<code>CPU</code>)</figcaption>
    </figure>
<h4 id="structure--control-unit">Structure – Control Unit</h4>
<figure><a class="lightgallery" href="/img/Computer%20Organization%20and%20Architecture/chapter1-6.png" title="/img/Computer Organization and Architecture/chapter1-6.png" data-thumbnail="/img/Computer Organization and Architecture/chapter1-6.png" data-sub-html="<h2>Structure(Control)</h2>">
        
    </a><figcaption class="image-caption">Structure(<code>Control</code>)</figcaption>
    </figure>
<h3 id="key-terms">Key terms</h3>
<table>
<thead>
<tr>
<th>Computer</th>
<th style="text-align:left">Computer Organization</th>
<th>Computer Architecture</th>
<th>Family of Computer models</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hierarchical System</td>
<td style="text-align:left">Structure</td>
<td>Function</td>
<td>Peripheral</td>
</tr>
<tr>
<td>Data Processing</td>
<td style="text-align:left">Data Storage</td>
<td>Data Movement</td>
<td>Control</td>
</tr>
<tr>
<td>Central Processing Unit</td>
<td style="text-align:left">Main Memory</td>
<td>I/O</td>
<td>System Interconnection</td>
</tr>
<tr>
<td>Control Unit</td>
<td style="text-align:left">Arithmetic and Logic Unit</td>
<td>Registers</td>
<td>CPU Interconnection</td>
</tr>
</tbody>
</table>
<h3 id="summarize">summarize</h3>
<ul>
<li>
<p><strong>Organization and Architecture</strong></p>
<ul>
<li>
<p><strong>Architecture is those attributes visible to the programmer</strong></p>
<ul>
<li><strong>Instruction set , number of bits used for data representation, I/O mechanisms, addressing techniques</strong></li>
</ul>
</li>
<li>
<p><strong>Organization is how features are implemented</strong></p>
<ul>
<li><strong>Control signals, interfaces, memory technology</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Structure &amp; Function</strong></p>
<ul>
<li>
<p>Structure is the way in which components relate to each other</p>
</li>
<li>
<p>Function is the operation of individual components as part of the structure</p>
</li>
</ul>
</li>
<li>
<p>The top level functions of a computer include data processing, data storage, data movement, and control.</p>
</li>
<li>
<p>The components of a computer include: CPU, memory, I/O, interconnect bus.</p>
</li>
</ul>
]]></description>
</item>
</channel>
</rss>
